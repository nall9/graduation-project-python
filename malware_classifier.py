import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox
import json
from datetime import datetime
import os
import hashlib
import magic
import threading
import webbrowser
from PIL import Image, ImageTk  # For custom icons
import time
from static_analyzer import StaticAnalyzer
from dynamic_analyzer import DynamicAnalyzer
from ml_classifier import MLClassifier
from threat_intelligence import ThreatIntelligence
from response_handler import ResponseHandler
import psutil
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import sqlite3
from collections import defaultdict
import platform
import socket
import uuid
import io
import base64
import math
import signal
import sys
import re

class ToolTip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip = None
        self.widget.bind("<Enter>", self.show_tooltip)
        self.widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event=None):
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25

        self.tooltip = tk.Toplevel(self.widget)
        self.tooltip.wm_overrideredirect(True)
        self.tooltip.wm_geometry(f"+{x}+{y}")

        label = ttk.Label(
            self.tooltip,
            text=self.text,
            justify=tk.LEFT,
            background="#ffffe0",
            relief=tk.SOLID,
            borderwidth=1,
            font=("Segoe UI", "9", "normal"),
            padding=(5, 2)
        )
        label.pack()

    def hide_tooltip(self, event=None):
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None

class ScrolledFrame(ttk.Frame):
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)
        
        # Create canvas and scrollbar
        self.canvas = tk.Canvas(self, highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        
        # Create the scrollable frame inside the canvas
        self.scrolled_frame = ttk.Frame(self.canvas)
        
        # Configure the canvas
        self.canvas_frame = self.canvas.create_window((0, 0), window=self.scrolled_frame, anchor="nw")
        
        # Configure scrolling
        self.scrolled_frame.bind("<Configure>", self.configure_scroll_region)
        self.canvas.bind("<Configure>", self.configure_canvas_window)
        
        # Bind mouse wheel
        self.bind_mouse_wheel(self)
        self.bind_mouse_wheel(self.canvas)
        self.bind_mouse_wheel(self.scrolled_frame)
        
        # Grid layout
        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Configure grid weights
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        
        # Configure canvas scroll
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
    def configure_scroll_region(self, event=None):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
    def configure_canvas_window(self, event=None):
        # Update the width of the canvas window
        self.canvas.itemconfig(self.canvas_frame, width=event.width)
        
    def bind_mouse_wheel(self, widget):
        widget.bind("<MouseWheel>", self._on_mousewheel)  # Windows
        widget.bind("<Button-4>", self._on_mousewheel)    # Linux
        widget.bind("<Button-5>", self._on_mousewheel)    # Linux
        
    def _on_mousewheel(self, event):
        if event.num == 4 or event.delta > 0:
            self.canvas.yview_scroll(-1, "units")
        elif event.num == 5 or event.delta < 0:
            self.canvas.yview_scroll(1, "units")

class CustomButton(ttk.Button):
    def __init__(self, master=None, **kwargs):
        self.hover_color = kwargs.pop('hover_color', '#1976d2')
        self.normal_color = kwargs.pop('normal_color', '#2196f3')
        super().__init__(master, **kwargs)
        self.bind('<Enter>', self.on_enter)
        self.bind('<Leave>', self.on_leave)
        
    def on_enter(self, e):
        self.configure(style='Hover.TButton')
        
    def on_leave(self, e):
        self.configure(style='Action.TButton')

class AnimatedProgressbar(ttk.Progressbar):
    def __init__(self, parent, **kwargs):
        # Set default mode if not provided
        if 'mode' not in kwargs:
            kwargs['mode'] = 'determinate'
        # Initialize with proper ttk.Progressbar parameters
        super().__init__(parent, **kwargs)
        self._animation_value = 0
        self._animating = False
        
    def start_animation(self):
        self._animating = True
        self._animate()
        
    def stop_animation(self):
        self._animating = False
        self['value'] = 0
        
    def _animate(self):
        if not self._animating:
            return
        self._animation_value = (self._animation_value + 5) % 100
        self['value'] = self._animation_value
        self.after(50, self._animate)

class ModernButton(tk.Canvas):
    def __init__(self, parent, text, command=None, width=120, height=35, 
                 bg_color="#2196F3", hover_color="#1976D2", text_color="#FFFFFF",
                 font=("Segoe UI", 10, "bold"), radius=8):
        super().__init__(parent, width=width, height=height, 
                        bg=parent["bg"], highlightthickness=0)
        self.command = command
        self.bg_color = bg_color
        self.hover_color = hover_color
        self.text_color = text_color
        self.font = font
        self.radius = radius
        
        # Create button shape
        self.rect = self.create_rounded_rect(0, 0, width, height, radius, fill=bg_color)
        self.text = self.create_text(width/2, height/2, text=text, fill=text_color, 
                                   font=font, tags="text")
        
        # Bind events
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)
        self.bind("<Button-1>", self._on_click)
        
    def create_rounded_rect(self, x1, y1, x2, y2, radius, **kwargs):
        points = [
            x1 + radius, y1,
            x2 - radius, y1,
            x2, y1,
            x2, y1 + radius,
            x2, y2 - radius,
            x2, y2,
            x2 - radius, y2,
            x1 + radius, y2,
            x1, y2,
            x1, y2 - radius,
            x1, y1 + radius,
            x1, y1
        ]
        return self.create_polygon(points, smooth=True, **kwargs)
        
    def _on_enter(self, e):
        self.itemconfig(self.rect, fill=self.hover_color)
        
    def _on_leave(self, e):
        self.itemconfig(self.rect, fill=self.bg_color)
        
    def _on_click(self, e):
        if self.command:
            self.command()

class AnimatedProgressBar(tk.Canvas):
    def __init__(self, parent, width=300, height=20, bg_color="#E0E0E0",
                 progress_color="#2196F3", text_color="white"):
        super().__init__(parent, width=width, height=height,
                        bg=parent["bg"], highlightthickness=0)
        self.bg_color = bg_color
        self.progress_color = progress_color
        self.text_color = text_color
        self.progress = 0
        self.target_progress = 0
        self.animation_speed = 0.1
        
        # Create background
        self.create_rounded_rect(0, 0, width, height, 10, fill=bg_color)
        self.progress_bar = self.create_rounded_rect(0, 0, 0, height, 10, 
                                                   fill=progress_color)
        self.text = self.create_text(width/2, height/2, text="0%",
                                   fill=text_color, font=("Segoe UI", 9))
        
    def create_rounded_rect(self, x1, y1, x2, y2, radius, **kwargs):
        points = [
            x1 + radius, y1,
            x2 - radius, y1,
            x2, y1,
            x2, y1 + radius,
            x2, y2 - radius,
            x2, y2,
            x2 - radius, y2,
            x1 + radius, y2,
            x1, y2,
            x1, y2 - radius,
            x1, y1 + radius,
            x1, y1
        ]
        return self.create_polygon(points, smooth=True, **kwargs)
        
    def set_progress(self, value):
        self.target_progress = value
        self._animate()
        
    def _animate(self):
        if abs(self.progress - self.target_progress) > 0.1:
            self.progress += (self.target_progress - self.progress) * self.animation_speed
            width = self.winfo_width()
            progress_width = int(width * (self.progress / 100))
            self.coords(self.progress_bar, 0, 0, progress_width, self.winfo_height())
            self.itemconfig(self.text, text=f"{int(self.progress)}%")
            self.after(16, self._animate)

class ModernFrame(tk.Frame):
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self.configure(bg=parent["bg"])
        
        # Add shadow effect with a valid color
        self.shadow = tk.Frame(self, bg="#E0E0E0")  # Light gray shadow
        self.shadow.place(x=2, y=2, relwidth=1, relheight=1)
        
        # Main content frame
        self.content = tk.Frame(self, bg=self["bg"])
        self.content.place(x=0, y=0, relwidth=1, relheight=1)

class ModernTab(ttk.Notebook):
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self.style = ttk.Style()
        self.style.configure("Modern.TNotebook", background="#F5F5F5")
        self.style.configure("Modern.TNotebook.Tab", 
                           padding=[12, 4], font=("Segoe UI", 10))
        self.configure(style="Modern.TNotebook")

class StaticAnalyzer:
    def __init__(self):
        self.yara_rules = []
        self._load_yara_rules()
    
    def _load_yara_rules(self):
        # TODO: Load YARA rules from a rules directory
        pass
    
    def analyze(self, filepath):
        try:
            results = {
                'file_info': self._get_file_info(filepath),
                'strings_analysis': self._analyze_strings(filepath),
                'header_analysis': self._analyze_headers(filepath),
                'yara_matches': self._check_yara_rules(filepath)
            }
            return results
        except Exception as e:
            return {'error': str(e)}
    
    def _get_file_info(self, filepath):
        stat = os.stat(filepath)
        with open(filepath, 'rb') as f:
            content = f.read()
            md5 = hashlib.md5(content).hexdigest()
            sha256 = hashlib.sha256(content).hexdigest()
        
        return {
            'size': stat.st_size,
            'created': datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S'),
            'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
            'md5': md5,
            'sha256': sha256,
            'mime_type': magic.from_file(filepath, mime=True)
        }
    
    def _analyze_strings(self, filepath):
        # TODO: Implement string analysis
        return {'suspicious_strings': []}
    
    def _analyze_headers(self, filepath):
        # TODO: Implement header analysis
        return {'header_info': {}}
    
    def _check_yara_rules(self, filepath):
        # TODO: Implement YARA rule checking
        return {'matches': []}

class DynamicAnalyzer:
    def __init__(self):
        self.sandbox_active = False
    
    def analyze(self, filepath):
        try:
            results = {
                'process_behavior': self._monitor_process_behavior(),
                'network_activity': self._monitor_network_activity(),
                'file_operations': self._monitor_file_operations(),
                'registry_changes': self._monitor_registry_changes()
            }
            return results
        except Exception as e:
            return {'error': str(e)}
    
    def _monitor_process_behavior(self):
        # TODO: Implement process monitoring
        return {'processes': []}
    
    def _monitor_network_activity(self):
        # TODO: Implement network monitoring
        return {'connections': []}
    
    def _monitor_file_operations(self):
        # TODO: Implement file operation monitoring
        return {'operations': []}
    
    def _monitor_registry_changes(self):
        # TODO: Implement registry monitoring
        return {'changes': []}

class MLClassifier:
    def __init__(self):
        self.model = None
        self._initialize_model()
    
    def _initialize_model(self):
        # TODO: Load or initialize ML model
        pass
    
    def classify(self, filepath):
        try:
            # Simulate ML classification with basic heuristics
            file_size = os.path.getsize(filepath)
            with open(filepath, 'rb') as f:
                content = f.read()
            
            # Calculate entropy
            entropy = self._calculate_entropy(content)
            
            # Simple risk score calculation
            risk_score = min(100, max(0, entropy * 10))
            
            return {
                'risk_score': risk_score,
                'confidence': 0.75,
                'classification': 'malicious' if risk_score > 70 else 'suspicious' if risk_score > 40 else 'benign',
                'features': {
                    'entropy': entropy,
                    'file_size': file_size
                }
            }
        except Exception as e:
            return {'error': str(e)}
    
    def _calculate_entropy(self, data):
        if not data:
            return 0
        
        entropy = 0
        for x in range(256):
            p_x = data.count(x) / len(data)
            if p_x > 0:
                entropy += -p_x * math.log2(p_x)
        return entropy / 8

class ThreatIntelligence:
    def __init__(self):
        self.cache_file = 'cache/threat_intel.json'
        self._initialize_cache()
    
    def _initialize_cache(self):
        os.makedirs('cache', exist_ok=True)
        if not os.path.exists(self.cache_file):
            with open(self.cache_file, 'w') as f:
                json.dump({}, f)
    
    def check_file(self, filepath):
        try:
            # Calculate file hashes
            with open(filepath, 'rb') as f:
                content = f.read()
                md5 = hashlib.md5(content).hexdigest()
                sha256 = hashlib.sha256(content).hexdigest()
            
            # Check cache
            cached_result = self._check_cache(sha256)
            if cached_result:
                return cached_result
            
            # Simulate threat intelligence check
            result = {
                'md5': md5,
                'sha256': sha256,
                'threats': [],
                'reputation': 'unknown',
                'first_seen': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'last_seen': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            # Cache result
            self._cache_result(sha256, result)
            
            return result
        except Exception as e:
            return {'error': str(e)}
    
    def _check_cache(self, file_hash):
        try:
            with open(self.cache_file, 'r') as f:
                cache = json.load(f)
                return cache.get(file_hash)
        except:
            return None
    
    def _cache_result(self, file_hash, result):
        try:
            with open(self.cache_file, 'r') as f:
                cache = json.load(f)
            
            cache[file_hash] = result
            
            with open(self.cache_file, 'w') as f:
                json.dump(cache, f)
        except:
            pass

class MalwareClassifierGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced Malware Classification System")
        self.root.geometry("1200x800")
        
        # Initialize analyzers
        self.static_analyzer = StaticAnalyzer()
        self.dynamic_analyzer = DynamicAnalyzer()
        self.ml_classifier = MLClassifier()
        self.threat_intel = ThreatIntelligence()
        
        # Initialize color scheme
        self.colors = {
            'light': {
                'background': '#FFFFFF',
                'foreground': '#212121',
                'accent': '#2196F3',
                'success': '#4CAF50',
                'warning': '#FFC107',
                'error': '#F44336',
                'card_bg': '#F5F5F5',
                'border': '#E0E0E0',
                'text': '#212121',
                'text_secondary': '#757575'
            },
            'dark': {
                'background': '#121212',
                'foreground': '#FFFFFF',
                'accent': '#64B5F6',
                'success': '#81C784',
                'warning': '#FFD54F',
                'error': '#E57373',
                'card_bg': '#1E1E1E',
                'border': '#424242',
                'text': '#FFFFFF',
                'text_secondary': '#B0B0B0'
            }
        }
        
        # Set default theme
        self.current_colors = self.colors['light']
        self.root.configure(bg=self.current_colors['background'])
        
        # Initialize variables
        self.file_path = tk.StringVar()
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        self.dark_mode = tk.BooleanVar(value=False)
        self.progress_var = tk.DoubleVar(value=0)  # Initialize progress_var
        
        # Initialize file details variables
        self.file_details = {
            'Name': tk.StringVar(),
            'Size': tk.StringVar(),
            'Type': tk.StringVar(),
            'MD5': tk.StringVar(),
            'SHA256': tk.StringVar(),
            'Created': tk.StringVar(),
            'Modified': tk.StringVar()
        }
        
        # Initialize monitoring state
        self.monitoring = False
        self.sandbox_active = False
        
        # Initialize analysis options
        self.analysis_options = {
            "deep_scan": tk.BooleanVar(value=True),
            "network_analysis": tk.BooleanVar(value=True),
            "memory_analysis": tk.BooleanVar(value=True),
            "behavior_analysis": tk.BooleanVar(value=True),
            "sandbox_analysis": tk.BooleanVar(value=True),
            "heuristic_analysis": tk.BooleanVar(value=True),
            "yara_scanning": tk.BooleanVar(value=True),
            "entropy_analysis": tk.BooleanVar(value=True),
            "api_monitoring": tk.BooleanVar(value=True),
            "registry_monitoring": tk.BooleanVar(value=True)
        }
        
        # Initialize analysis info
        self.analysis_info = {
            'deep_scan': {
                'description': "Performs comprehensive file analysis including signature matching, behavior analysis, and heuristic detection",
                'features': ["Signature matching", "Behavior analysis", "Heuristic detection"]
            },
            'network_analysis': {
                'description': "Analyzes network traffic patterns and connections made by the file",
                'features': ["Traffic pattern analysis", "Connection monitoring", "Protocol analysis"]
            },
            'memory_analysis': {
                'description': "Examines memory usage and patterns during file execution",
                'features': ["Memory pattern analysis", "Heap analysis", "Stack analysis"]
            },
            'behavior_analysis': {
                'description': "Monitors and analyzes file behavior during execution",
                'features': ["Process monitoring", "File system activity", "Registry activity"]
            },
            'sandbox_analysis': {
                'description': "Executes the file in a controlled environment to observe its behavior",
                'features': ["Isolated execution", "Behavior observation", "System interaction monitoring"]
            },
            'heuristic_analysis': {
                'description': "Uses pattern matching and statistical analysis to detect unknown malware",
                'features': ["Pattern matching", "Statistical analysis", "Anomaly detection"]
            },
            'yara_scanning': {
                'description': "Scans the file against YARA rules for known malware patterns",
                'features': ["Pattern matching", "Rule-based detection", "Custom rule support"]
            },
            'entropy_analysis': {
                'description': "Analyzes file entropy to detect encryption or packing",
                'features': ["Entropy calculation", "Packing detection", "Encryption detection"]
            },
            'api_monitoring': {
                'description': "Monitors API calls made by the file during execution",
                'features': ["API call tracking", "Function hooking", "System call analysis"]
            },
            'registry_monitoring': {
                'description': "Monitors registry changes made by the file",
                'features': ["Registry change tracking", "Persistence detection", "Configuration analysis"]
            }
        }
        
        # Initialize database
        self.init_database()
        
        # Setup UI
        self.setup_ui()
        
        # Center window
        self.center_window()
        
    def center_window(self):
        """Center the window on the screen."""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')
        
    def setup_ui(self):
        # Create a canvas with scrollbar for the main container
        canvas = tk.Canvas(self.root, bg=self.current_colors['background'], highlightthickness=0)
        scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=canvas.yview)
        
        # Create main container with padding
        self.main_container = ModernFrame(canvas, padx=20, pady=20)
        
        # Configure canvas
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Pack scrollbar and canvas
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Create a window in the canvas for the main container
        canvas_frame = canvas.create_window((0, 0), window=self.main_container, anchor="nw")
        
        # Configure canvas to expand with the main container
        def configure_canvas(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
            # Make the canvas window expand to the canvas width
            canvas.itemconfig(canvas_frame, width=event.width)
        
        # Bind events for scrolling
        self.main_container.bind("<Configure>", configure_canvas)
        canvas.bind("<Configure>", lambda e: canvas.itemconfig(canvas_frame, width=e.width))
        
        # Bind mouse wheel for scrolling
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        # Header section with title and buttons
        header_frame = ModernFrame(self.main_container)
        header_frame.pack(fill=tk.X, pady=(0, 20))
        
        title_label = tk.Label(header_frame, 
                             text="Advanced Malware Classification System",
                             font=("Segoe UI", 24, "bold"),
                             bg=header_frame["bg"],
                             fg="#1976D2")
        title_label.pack(side=tk.LEFT)
        
        # Button container for top-right buttons
        button_container = ModernFrame(header_frame)
        button_container.pack(side=tk.RIGHT)
        
        # Theme toggle button
        theme_btn = ModernButton(button_container, "üåô Dark Mode",
                               command=self.toggle_theme,
                               width=120, height=35,
                               bg_color="#424242",
                               hover_color="#616161",
                               text_color="#FFFFFF")
        theme_btn.pack(side=tk.LEFT, padx=5)
        
        # Exit button
        exit_btn = ModernButton(button_container, "‚ùå Exit",
                              command=self.exit_application,
                              width=100, height=35,
                              bg_color="#f44336",
                              hover_color="#d32f2f",
                              text_color="#FFFFFF")
        exit_btn.pack(side=tk.LEFT, padx=5)
        
        # File selection section
        file_frame = ModernFrame(self.main_container)
        file_frame.pack(fill=tk.X, pady=(0, 20))
        
        # File selection area
        file_select_frame = ModernFrame(file_frame)
        file_select_frame.pack(fill=tk.X, pady=10)
        
        file_label = tk.Label(file_select_frame,
                            text="Select File for Analysis:",
                            font=("Segoe UI", 12),
                            bg=file_select_frame["bg"])
        file_label.pack(side=tk.LEFT, padx=(0, 10))
        
        file_entry = tk.Entry(file_select_frame,
                            textvariable=self.file_path,
                            font=("Segoe UI", 10),
                            width=50)
        file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        
        browse_btn = ModernButton(file_select_frame, "Browse",
                                command=self.browse_file,
                                width=100, height=35,
                                bg_color="#2196F3",
                                hover_color="#1976D2",
                                text_color="#FFFFFF")
        browse_btn.pack(side=tk.LEFT)
        
        # Advanced features buttons section
        advanced_frame = ModernFrame(self.main_container)
        advanced_frame.pack(fill=tk.X, pady=(0, 20))
        
        # Create a label for the advanced features section
        advanced_label = tk.Label(advanced_frame,
                                text="Advanced Features",
                                font=("Segoe UI", 12, "bold"),
                                bg=advanced_frame["bg"])
        advanced_label.pack(anchor=tk.W, pady=(0, 10))
        
        # Create button container for advanced features
        button_container = ModernFrame(advanced_frame)
        button_container.pack(fill=tk.X)
        
        # Add advanced feature buttons
        history_btn = ModernButton(button_container, "Analysis History",
                                 command=self.show_history,
                                 width=150, height=35,
                                 bg_color="#2196F3",
                                 hover_color="#1976D2",
                                 text_color="#FFFFFF")
        history_btn.pack(side=tk.LEFT, padx=5)
        
        stats_btn = ModernButton(button_container, "Statistics Dashboard",
                               command=self.show_statistics,
                               width=150, height=35,
                               bg_color="#2196F3",
                               hover_color="#1976D2",
                               text_color="#FFFFFF")
        stats_btn.pack(side=tk.LEFT, padx=5)
        
        monitoring_btn = ModernButton(button_container, "Real-time Monitoring",
                                    command=self.toggle_monitoring,
                                    width=150, height=35,
                                    bg_color="#2196F3",
                                    hover_color="#1976D2",
                                    text_color="#FFFFFF")
        monitoring_btn.pack(side=tk.LEFT, padx=5)
        
        sandbox_btn = ModernButton(button_container, "Sandbox Mode",
                                 command=self.toggle_sandbox,
                                 width=150, height=35,
                                 bg_color="#2196F3",
                                 hover_color="#1976D2",
                                 text_color="#FFFFFF")
        sandbox_btn.pack(side=tk.LEFT, padx=5)
        
        # Analysis options section
        options_frame = ModernFrame(self.main_container)
        options_frame.pack(fill=tk.X, pady=(0, 20))
        
        options_label = tk.Label(options_frame,
                               text="Analysis Options",
                               font=("Segoe UI", 12, "bold"),
                               bg=options_frame["bg"])
        options_label.pack(anchor=tk.W, pady=(0, 10))
        
        # Create two columns for options
        options_container = ModernFrame(options_frame)
        options_container.pack(fill=tk.X)
        
        left_column = ModernFrame(options_container)
        left_column.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        
        right_column = ModernFrame(options_container)
        right_column.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Create modern checkboxes
        for i, (option, var) in enumerate(self.analysis_options.items()):
            parent = left_column if i < 5 else right_column
            cb_frame = ModernFrame(parent)
            cb_frame.pack(fill=tk.X, pady=2)
            
            # Convert option key to display text
            display_text = option.replace('_', ' ').title()
            
            cb = tk.Checkbutton(cb_frame,
                              text=display_text,
                              variable=var,
                              font=("Segoe UI", 10),
                              bg=cb_frame["bg"],
                              activebackground=cb_frame["bg"],
                              selectcolor="#2196F3")
            cb.pack(side=tk.LEFT)
            
            # Add tooltip using the analysis_info dictionary
            if option in self.analysis_info:
                ToolTip(cb, self.analysis_info[option]['description'])
        
        # Analysis button and progress
        control_frame = ModernFrame(self.main_container)
        control_frame.pack(fill=tk.X, pady=(0, 20))
        
        self.progress_bar = AnimatedProgressBar(control_frame,
                                              width=300,
                                              height=20)
        self.progress_bar.pack(side=tk.LEFT, padx=(0, 20))
        
        analyze_btn = ModernButton(control_frame, "Analyze File",
                                 command=self.analyze_file,
                                 width=150, height=40,
                                 bg_color="#4CAF50",
                                 hover_color="#388E3C",
                                 text_color="#FFFFFF")
        analyze_btn.pack(side=tk.LEFT)
        
        # Results section
        results_frame = ModernFrame(self.main_container)
        results_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create modern notebook for results
        self.notebook = ModernTab(results_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Create analysis tabs
        self.create_analysis_section()
        
        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set("Ready")
        status_bar = tk.Label(self.main_container,
                            textvariable=self.status_var,
                            font=("Segoe UI", 9),
                            bg="#E0E0E0",
                            fg="#424242")
        status_bar.pack(fill=tk.X, pady=(10, 0))

    def create_analysis_section(self):
        # Create tabs with info panels
        self.text_widgets = {}
        
        # Define tab names and their info
        tabs = {
            'static_analysis': {
                'title': 'Static Analysis',
                'description': 'Performs static analysis of file contents and structure',
                'features': ['File information', 'String analysis', 'Header analysis', 'YARA scanning']
            },
            'dynamic_analysis': {
                'title': 'Dynamic Analysis',
                'description': 'Analyzes runtime behavior and system interactions',
                'features': ['Process monitoring', 'Network activity', 'File operations', 'Registry changes']
            },
            'ml_classification': {
                'title': 'ML Classification',
                'description': 'Machine learning based classification and risk assessment',
                'features': ['Risk scoring', 'Feature analysis', 'Pattern detection', 'Anomaly detection']
            },
            'threat_intelligence': {
                'title': 'Threat Intelligence',
                'description': 'Checks file against known threats and reputation data',
                'features': ['Hash checking', 'Reputation analysis', 'Threat matching', 'Intelligence feeds']
            }
        }
        
        # Create notebook for results
        self.notebook = ttk.Notebook(self.main_container)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Create each tab
        for tab_id, info in tabs.items():
            tab_frame = ttk.Frame(self.notebook, style='Surface.TFrame')
            
            # Info panel
            info_frame = ttk.Frame(tab_frame, style='Surface.TFrame')
            info_frame.pack(fill=tk.X, padx=5, pady=5)
            
            ttk.Label(
                info_frame,
                text=info['description'],
                style='Info.TLabel'
            ).pack(anchor=tk.W, padx=5)
            
            # Features list
            features_frame = ttk.Frame(info_frame, style='Surface.TFrame')
            features_frame.pack(fill=tk.X, padx=20, pady=5)
            
            for feature in info['features']:
                ttk.Label(
                    features_frame,
                    text=f"‚Ä¢ {feature}",
                    style='Info.TLabel'
                ).pack(anchor=tk.W)
            
            # Results text widget
            text_widget = scrolledtext.ScrolledText(
                tab_frame,
                wrap=tk.WORD,
                width=80,
                height=20,
                font=('Consolas', 10),
                bg=self.current_colors['card_bg'],
                fg=self.current_colors['text']
            )
            text_widget.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            
            self.notebook.add(tab_frame, text=info['title'])
            self.text_widgets[tab_id] = text_widget
            
            # Add status indicator
            status_frame = ttk.Frame(tab_frame)
            status_frame.pack(fill=tk.X, padx=5, pady=2)
            
            status_var = tk.StringVar(value='Ready')
            ttk.Label(
                status_frame,
                textvariable=status_var,
                style='Info.TLabel'
            ).pack(side=tk.LEFT)
            
            setattr(self, f'{tab_id}_status', status_var)
            
            # Add progress bar (without specifying mode since it's handled in the class)
            progress = AnimatedProgressbar(
                status_frame,
                length=100
            )
            progress.pack(side=tk.RIGHT, padx=5)
            setattr(self, f'{tab_id}_progress', progress)

    def create_status_indicator(self, parent, tab_name):
        frame = ttk.Frame(parent)
        frame.pack(side=tk.LEFT, padx=5)
        
        status_var = tk.StringVar(value='Waiting')
        label = ttk.Label(
            frame,
            textvariable=status_var,
            style='Info.TLabel'
        )
        label.pack(side=tk.LEFT)
        
        setattr(self, f'{tab_name.lower().replace(" ", "_")}_status', status_var)

    def create_status_bar(self):
        status_frame = ttk.Frame(self.root, style='Surface.TFrame')
        status_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.status_var = tk.StringVar()
        self.status_bar = ttk.Label(
            status_frame,
            textvariable=self.status_var,
            font=('Segoe UI', 10),
            foreground=self.current_colors['text_secondary']
        )
        self.status_bar.pack(side=tk.LEFT, padx=10)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            status_frame,
            variable=self.progress_var,
            maximum=100,
            length=200
        )
        self.progress_bar.pack(side=tk.RIGHT, padx=10)

    def create_menu(self):
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Open File", command=self.browse_file)
        file_menu.add_command(label="Open Multiple Files", command=self.browse_multiple_files)
        file_menu.add_separator()
        file_menu.add_command(label="Save Results", command=self.export_json)
        file_menu.add_command(label="Generate Report", command=self.generate_report)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_checkbutton(label="Dark Mode", 
                                variable=self.dark_mode,
                                command=self.toggle_theme)
        
        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="Update YARA Rules", 
                             command=self.update_yara_rules)
        tools_menu.add_command(label="Update ML Model", 
                             command=self.update_ml_model)
        tools_menu.add_command(label="Clear Cache", 
                             command=self.clear_cache)
        
        # Advanced menu
        advanced_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Advanced", menu=advanced_menu)
        advanced_menu.add_checkbutton(label="Real-time Monitoring", 
                                    command=self.toggle_monitoring)
        advanced_menu.add_checkbutton(label="Sandbox Mode", 
                                    command=self.toggle_sandbox)
        advanced_menu.add_command(label="Analysis History", 
                                command=self.show_history)
        advanced_menu.add_command(label="Statistics Dashboard", 
                                command=self.show_statistics)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", 
                            command=lambda: webbrowser.open("https://github.com/yourusername/malware-classifier/docs"))
        help_menu.add_command(label="About", command=self.show_about)

    def toggle_theme(self):
        """Toggle between light and dark themes."""
        # Toggle the dark_mode value
        self.dark_mode.set(not self.dark_mode.get())
        
        # Update colors based on the new theme
        self.current_colors = self.colors['dark' if self.dark_mode.get() else 'light']
        
        # Update the root window background
        self.root.configure(bg=self.current_colors['background'])
        
        # Update all widgets with the new theme
        self.apply_theme()
        
        # Update the theme button text
        theme_text = "‚òÄÔ∏è Light Mode" if self.dark_mode.get() else "üåô Dark Mode"
        for widget in self.root.winfo_children():
            if isinstance(widget, tk.Canvas):
                for child in widget.winfo_children():
                    if isinstance(child, ModernFrame):
                        for grandchild in child.winfo_children():
                            if isinstance(grandchild, ModernFrame):
                                for great_grandchild in grandchild.winfo_children():
                                    if isinstance(great_grandchild, ModernButton):
                                        great_grandchild.itemconfig("text", text=theme_text)
                                        break

    def apply_theme(self):
        # Update root background
        self.root.configure(bg=self.current_colors['background'])
        
        # Update all frames
        for widget in self.root.winfo_children():
            if isinstance(widget, (ttk.Frame, ttk.LabelFrame)):
                widget.configure(style='Main.TFrame')
        
        # Update text widgets
        for text_widget in self.text_widgets.values():
            text_widget.configure(
                bg=self.current_colors['card_bg'],
                fg=self.current_colors['text'],
                insertbackground=self.current_colors['text']
            )

    def browse_file(self):
        filepath = filedialog.askopenfilename()
        if filepath:
            self.file_path.set(filepath)
            self.update_file_details(filepath)

    def update_file_details(self, filepath):
        try:
            stat = os.stat(filepath)
            with open(filepath, 'rb') as f:
                content = f.read()
                md5 = hashlib.md5(content).hexdigest()
                sha256 = hashlib.sha256(content).hexdigest()
            
            self.file_details['Name'].set(os.path.basename(filepath))
            self.file_details['Size'].set(f"{stat.st_size:,} bytes")
            self.file_details['Type'].set(magic.from_file(filepath))
            self.file_details['MD5'].set(md5)
            self.file_details['SHA256'].set(sha256)
            self.file_details['Created'].set(datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S'))
            self.file_details['Modified'].set(datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S'))
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read file details: {str(e)}")

    def analyze_file(self):
        filepath = self.file_path.get()
        if not filepath:
            self.show_error("Please select a file first")
            return
        
        if not os.path.exists(filepath):
            self.show_error("Selected file does not exist")
            return
            
        self.status_var.set("Analyzing file...")
        self.progress_bar.set_progress(0)
        
        def run_analysis():
            try:
                # Static Analysis
                self.progress_bar.set_progress(20)
                static_results = {
                    'file_info': self._get_file_info(filepath),
                    'strings_analysis': self._analyze_strings(filepath),
                    'header_analysis': self._analyze_headers(filepath),
                    'yara_matches': []
                }
                self.update_tab_content('static_analysis', static_results)
                
                # Dynamic Analysis
                self.progress_bar.set_progress(40)
                dynamic_results = {
                    'process_behavior': {'processes': []},
                    'network_activity': {'connections': []},
                    'file_operations': {'operations': []},
                    'registry_changes': {'changes': []}
                }
                self.update_tab_content('dynamic_analysis', dynamic_results)
                
                # ML Classification
                self.progress_bar.set_progress(60)
                ml_results = self._analyze_ml(filepath)
                self.update_tab_content('ml_classification', ml_results)
                
                # Threat Intelligence
                self.progress_bar.set_progress(80)
                threat_results = self._check_threat_intel(filepath)
                self.update_tab_content('threat_intelligence', threat_results)
                
                # Store results in database using thread-safe method
                self.store_analysis_results(
                    filepath,
                    static_results,
                    dynamic_results,
                    ml_results,
                    threat_results
                )
                
                self.progress_bar.set_progress(100)
                self.status_var.set("Analysis complete")
                self.show_success("File analysis completed successfully")
                
            except Exception as e:
                self.status_var.set("Analysis failed")
                self.show_error(f"Analysis failed: {str(e)}")
            
        thread = threading.Thread(target=run_analysis)
        thread.start()

    def _get_file_info(self, filepath):
        """Get basic file information."""
        try:
            stat = os.stat(filepath)
            with open(filepath, 'rb') as f:
                content = f.read()
                md5 = hashlib.md5(content).hexdigest()
                sha256 = hashlib.sha256(content).hexdigest()
            
            return {
                'name': os.path.basename(filepath),
                'size': stat.st_size,
                'created': datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S'),
                'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
                'md5': md5,
                'sha256': sha256,
                'mime_type': magic.from_file(filepath, mime=True)
            }
        except Exception as e:
            return {'error': str(e)}

    def _analyze_strings(self, filepath):
        """Analyze file for suspicious strings."""
        try:
            suspicious_patterns = [
                r'cmd\.exe\s+/c',
                r'powershell\.exe\s+-enc',
                r'rundll32\.exe',
                r'regsvr32\.exe',
                r'CreateRemoteThread',
                r'WriteProcessMemory',
                r'LoadLibraryA',
                r'WinExec',
                r'CreateProcess',
                r'VirtualAlloc',
                r'botnet',
                r'keylogger',
                r'rootkit',
                r'backdoor',
                r'ransomware',
                r'exploit',
                r'payload',
                r'shellcode',
                r'meterpreter',
                r'reverse shell',
                r'privilege escalation',
                r'persistence',
                r'lateral movement',
                r'data exfiltration'
            ]
            
            found_strings = []
            string_explanations = {
                r'cmd\.exe\s+/c': "Command prompt execution detected - Possible command injection",
                r'powershell\.exe\s+-enc': "PowerShell encoded command detected - Common in malware",
                r'rundll32\.exe': "DLL loading detected - Could be used for code execution",
                r'regsvr32\.exe': "Registry server registration detected - Possible persistence mechanism",
                r'CreateRemoteThread': "Remote thread creation detected - Possible process injection",
                r'WriteProcessMemory': "Process memory writing detected - Possible code injection",
                r'LoadLibraryA': "Dynamic library loading detected - Possible DLL injection",
                r'WinExec': "Windows execution detected - Possible program launching",
                r'CreateProcess': "Process creation detected - Possible program execution",
                r'VirtualAlloc': "Memory allocation detected - Possible shellcode execution",
                r'botnet': "Botnet-related string detected - Possible C2 communication",
                r'keylogger': "Keylogger-related string detected - Possible keylogging activity",
                r'rootkit': "Rootkit-related string detected - Possible system modification",
                r'backdoor': "Backdoor-related string detected - Possible unauthorized access",
                r'ransomware': "Ransomware-related string detected - Possible file encryption",
                r'exploit': "Exploit-related string detected - Possible vulnerability exploitation",
                r'payload': "Payload-related string detected - Possible malicious code",
                r'shellcode': "Shellcode-related string detected - Possible code execution",
                r'meterpreter': "Meterpreter-related string detected - Possible remote access",
                r'reverse shell': "Reverse shell-related string detected - Possible remote control",
                r'privilege escalation': "Privilege escalation-related string detected - Possible rights elevation",
                r'persistence': "Persistence-related string detected - Possible system modification",
                r'lateral movement': "Lateral movement-related string detected - Possible network propagation",
                r'data exfiltration': "Data exfiltration-related string detected - Possible data theft"
            }
            
            with open(filepath, 'rb') as f:
                content = f.read().decode('utf-8', errors='ignore')
                
            for pattern in suspicious_patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    found_strings.append({
                        'pattern': pattern,
                        'match': match.group(),
                        'position': match.start(),
                        'explanation': string_explanations.get(pattern, "Suspicious string detected")
                    })
            
            return found_strings
            
        except Exception as e:
            print(f"String analysis error: {e}")
            return []

    def _analyze_headers(self, filepath):
        """Analyze file headers and determine file type."""
        try:
            with open(filepath, 'rb') as f:
                header = f.read(4096)  # Read first 4KB
                
            # Common file signatures
            signatures = {
                b'MZ': 'Windows Executable',
                b'PE\x00\x00': 'Windows PE File',
                b'PK\x03\x04': 'ZIP Archive',
                b'%PDF': 'PDF Document',
                b'\x89PNG': 'PNG Image',
                b'GIF8': 'GIF Image',
                b'\xFF\xD8\xFF': 'JPEG Image',
                b'#!': 'Script File',
                b'\x7FELF': 'ELF Binary',
                b'\xCA\xFE\xBA\xBE': 'Java Class File'
            }
            
            # Check for packers/obfuscators
            packer_signatures = {
                b'UPX': 'UPX Packed',
                b'ASPack': 'ASPack Packed',
                b'PECompact': 'PECompact Packed',
                b'MPRESS': 'MPRESS Packed',
                b'FSG': 'FSG Packed',
                b'Petite': 'Petite Packed',
                b'RLPack': 'RLPack Packed',
                b'MEW': 'MEW Packed',
                b'Yoda': 'Yoda Packed',
                b'ASProtect': 'ASProtect Protected'
            }
            
            file_type = "Unknown"
            packer_info = "No packer detected"
            
            # Check file signatures
            for sig, type_name in signatures.items():
                if header.startswith(sig):
                    file_type = type_name
                    break
            
            # Check for packers
            for sig, packer_name in packer_signatures.items():
                if sig in header:
                    packer_info = f"Detected {packer_name}"
                    break
            
            return {
                'type': file_type,
                'packer': packer_info,
                'header_analysis': {
                    'file_type': file_type,
                    'packer_detection': packer_info,
                    'explanation': f"File appears to be a {file_type}. {packer_info}."
                }
            }
            
        except Exception as e:
            print(f"Header analysis error: {e}")
            return {
                'type': 'Unknown',
                'packer': 'Unknown',
                'header_analysis': {
                    'file_type': 'Unknown',
                    'packer_detection': 'Unknown',
                    'explanation': f"Header analysis failed: {str(e)}"
                }
            }

    def _analyze_ml(self, filepath):
        """Perform machine learning based analysis."""
        try:
            # Calculate entropy
            entropy = self._calculate_entropy(filepath)
            
            # Get file size
            file_size = os.path.getsize(filepath)
            
            # Analyze strings
            suspicious_strings = self._analyze_strings(filepath)
            
            # Get file type
            file_type_info = self._analyze_headers(filepath)
            file_type = str(file_type_info.get('type', 'Unknown'))
            
            # Calculate risk score based on multiple factors
            risk_score = 0
            
            # Entropy analysis (higher entropy = more suspicious)
            if entropy > 7.0:
                risk_score += 30
                entropy_explanation = "High entropy detected - File contains encrypted or compressed data"
            elif entropy > 6.0:
                risk_score += 20
                entropy_explanation = "Moderate entropy detected - Possible obfuscation or encoding"
            else:
                risk_score += 10
                entropy_explanation = "Low entropy detected - Normal file content"
            
            # File size analysis
            if file_size > 10 * 1024 * 1024:  # > 10MB
                risk_score += 15
                size_explanation = "Large file size - Could contain embedded payloads"
            elif file_size < 1024:  # < 1KB
                risk_score += 10
                size_explanation = "Very small file size - Could be a dropper or loader"
            else:
                size_explanation = "Normal file size"
            
            # Suspicious string analysis
            if len(suspicious_strings) > 10:
                risk_score += 35
                string_explanation = f"High number of suspicious strings ({len(suspicious_strings)}) - Strong indicators of malicious behavior"
            elif len(suspicious_strings) > 5:
                risk_score += 25
                string_explanation = f"Moderate number of suspicious strings ({len(suspicious_strings)}) - Possible malicious intent"
            elif len(suspicious_strings) > 0:
                risk_score += 15
                string_explanation = f"Some suspicious strings found ({len(suspicious_strings)}) - Requires further investigation"
            else:
                string_explanation = "No suspicious strings found"
            
            # File type analysis
            if any(susp in file_type.lower() for susp in ['executable', 'dll', 'script']):
                risk_score += 20
                type_explanation = f"Suspicious file type detected: {file_type} - Higher risk of malicious behavior"
            else:
                type_explanation = f"File type: {file_type}"
            
            # Determine classification based on risk score
            if risk_score >= 90:
                classification = "MALICIOUS"
                classification_explanation = "File shows multiple strong indicators of malicious behavior"
            elif risk_score >= 70:
                classification = "SUSPICIOUS"
                classification_explanation = "File exhibits suspicious patterns that require investigation"
            elif risk_score >= 50:
                classification = "POTENTIALLY DANGEROUS"
                classification_explanation = "File shows some concerning patterns but may be legitimate"
            else:
                classification = "CLEAN"
                classification_explanation = "File appears to be clean with no significant suspicious indicators"
            
            # Create detailed analysis report
            analysis_report = {
                'entropy': float(entropy),
                'entropy_explanation': str(entropy_explanation),
                'file_size': float(file_size),
                'size_explanation': str(size_explanation),
                'suspicious_strings': int(len(suspicious_strings)),
                'string_explanation': str(string_explanation),
                'file_type': str(file_type),
                'type_explanation': str(type_explanation),
                'risk_score': float(risk_score),
                'classification': str(classification),
                'classification_explanation': str(classification_explanation),
                'detailed_findings': {
                    'entropy_analysis': {
                        'value': float(entropy),
                        'threshold': float(7.0),
                        'explanation': str(entropy_explanation)
                    },
                    'size_analysis': {
                        'value': float(file_size),
                        'threshold': float(10 * 1024 * 1024),
                        'explanation': str(size_explanation)
                    },
                    'string_analysis': {
                        'count': int(len(suspicious_strings)),
                        'threshold': int(5),
                        'explanation': str(string_explanation)
                    },
                    'type_analysis': {
                        'detected_type': str(file_type),
                        'explanation': str(type_explanation)
                    }
                }
            }
            
            return {
                'risk_score': float(risk_score),
                'classification': str(classification),
                'explanation': str(classification_explanation),
                'entropy': float(entropy),
                'file_size': float(file_size),
                'suspicious_strings': int(len(suspicious_strings)),
                'file_type': str(file_type),
                'detailed_report': analysis_report
            }
            
        except Exception as e:
            print(f"ML analysis error: {e}")
            return {
                'risk_score': float(0),
                'classification': str('ERROR'),
                'explanation': str(f'Analysis failed: {str(e)}'),
                'entropy': float(0),
                'file_size': float(0),
                'suspicious_strings': int(0),
                'file_type': str('Unknown'),
                'detailed_report': None
            }

    def _calculate_entropy(self, filepath):
        """Calculate Shannon entropy of file data."""
        try:
            with open(filepath, 'rb') as f:
                data = f.read()
            
            if not data:
                return 0
            
            # Calculate frequency of each byte value
            freq = {}
            for byte in data:
                freq[byte] = freq.get(byte, 0) + 1
            
            # Calculate entropy
            entropy = 0
            for count in freq.values():
                probability = count / len(data)
                entropy -= probability * math.log2(probability)
            
            return entropy / 8  # Normalize to 0-1 range
            
        except Exception as e:
            print(f"Entropy calculation error: {e}")
            return 0

    def _check_threat_intel(self, filepath):
        """Check file against threat intelligence."""
        try:
            with open(filepath, 'rb') as f:
                content = f.read()
                md5 = hashlib.md5(content).hexdigest()
                sha256 = hashlib.sha256(content).hexdigest()
            
            # Simulate threat intelligence check
            return {
                'md5': md5,
                'sha256': sha256,
                'threats': [],
                'reputation': 'unknown',
                'first_seen': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'last_seen': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'sources_checked': ['Local Database', 'File Reputation']
            }
        except Exception as e:
            return {'error': str(e)}

    def update_tab_content(self, tab_name, content):
        text_widget = self.text_widgets[tab_name]
        text_widget.delete('1.0', tk.END)
        
        # Add timestamp
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        text_widget.insert(tk.END, f"Analysis Time: {timestamp}\n\n")
        
        # Format and insert content
        if isinstance(content, dict):
            # Add summary section
            if 'error' in content and content['error']:
                text_widget.insert(tk.END, "‚ö†Ô∏è Analysis Status: Error\n")
                text_widget.insert(tk.END, f"Error: {content['error']}\n\n")
            else:
                text_widget.insert(tk.END, "‚úÖ Analysis Status: Complete\n\n")
            
            # Add formatted content
            formatted_content = json.dumps(content, indent=2)
            text_widget.insert(tk.END, "Detailed Results:\n")
            text_widget.insert(tk.END, formatted_content)
        else:
            text_widget.insert(tk.END, str(content))
        
        # Scroll to top
        text_widget.see("1.0")
        
        # Update status indicator
        status_var = getattr(self, f'{tab_name.lower().replace(" ", "_")}_status')
        progress_bar = getattr(self, f'{tab_name.lower().replace(" ", "_")}_progress')
        
        if isinstance(content, dict) and content.get('error'):
            status_var.set('‚ùå Error')
            progress_bar.stop_animation()
        else:
            status_var.set('‚úÖ Complete')
            progress_bar.stop_animation()

    def generate_report(self):
        if not os.path.exists('reports'):
            os.makedirs('reports')
            
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        report_file = f'reports/analysis_report_{timestamp}.html'
        
        try:
            with open(report_file, 'w') as f:
                f.write(self.generate_html_report())
            
            messagebox.showinfo("Success", f"Report generated: {report_file}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate report: {str(e)}")

    def generate_html_report(self):
        html = f"""
        <html>
        <head>
            <title>Malware Analysis Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                h1 {{ color: #333; }}
                .section {{ margin: 20px 0; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f5f5f5; }}
            </style>
        </head>
        <body>
            <h1>Malware Analysis Report</h1>
            <div class="section">
                <h2>File Information</h2>
                <table>
                    <tr><th>Property</th><th>Value</th></tr>
        """
        
        for key, var in self.file_details.items():
            html += f"<tr><td>{key}</td><td>{var.get()}</td></tr>"
        
        html += """
                </table>
            </div>
        """
        
        # Add analysis results
        for tab_name in ['Static Analysis', 'Dynamic Analysis', 'ML Classification', 'Threat Intelligence']:
            text_widget = self.text_widgets.get(tab_name)
            if text_widget:
                content = text_widget.get('1.0', tk.END)
                html += f"""
                <div class="section">
                    <h2>{tab_name}</h2>
                    <pre>{content}</pre>
                </div>
                """
        
        html += """
        </body>
        </html>
        """
        return html

    def clear_results(self):
        for text_widget in self.text_widgets.values():
            text_widget.delete('1.0', tk.END)
        self.status_var.set("")
        self.progress_var.set(0)
        
    def export_json(self):
        if not os.path.exists('exports'):
            os.makedirs('exports')
            
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        export_file = f'exports/analysis_results_{timestamp}.json'
        
        try:
            results = {}
            for tab_name, text_widget in self.text_widgets.items():
                content = text_widget.get('1.0', tk.END).strip()
                if content:
                    results[tab_name] = json.loads(content)
                    
            with open(export_file, 'w') as f:
                json.dump(results, f, indent=2)
                
            messagebox.showinfo("Success", f"Results exported to: {export_file}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export results: {str(e)}")

    def browse_multiple_files(self):
        filepaths = filedialog.askopenfilenames()
        if filepaths:
            self.batch_files = list(filepaths)
            self.status_var.set(f"Selected {len(self.batch_files)} files for batch analysis")
            
            # Update first file details
            self.file_path.set(self.batch_files[0])
            self.update_file_details(self.batch_files[0])
            
            # Enable batch analysis
            self.batch_analyze_button.configure(state='normal')

    def batch_analyze(self):
        if not self.batch_files:
            messagebox.showerror("Error", "No files selected for batch analysis")
            return
        
        self.is_analyzing = True
        self.status_var.set("Starting batch analysis...")
        self.progress_var.set(0)
        
        def run_batch_analysis():
            try:
                total_files = len(self.batch_files)
                for i, filepath in enumerate(self.batch_files, 1):
                    if not self.is_analyzing:  # Check if analysis was cancelled
                        break
                    
                    self.status_var.set(f"Analyzing file {i} of {total_files}: {os.path.basename(filepath)}")
                    self.progress_var.set((i - 1) * 100 / total_files)
                    
                    # Perform analysis
                    static_results = self.static_analyzer.analyze(filepath)
                    dynamic_results = self.dynamic_analyzer.analyze(filepath)
                    ml_results = self.ml_classifier.classify(filepath)
                    threat_results = self.threat_intel.check_file(filepath)
                    
                    # Generate individual report
                    self.generate_individual_report(
                        filepath, static_results, dynamic_results,
                        ml_results, threat_results
                    )
                
                if self.is_analyzing:  # If analysis wasn't cancelled
                    self.progress_var.set(100)
                    self.status_var.set("Batch analysis complete")
                    messagebox.showinfo("Success", "Batch analysis completed successfully")
                
            except Exception as e:
                self.status_var.set("Batch analysis failed")
                messagebox.showerror("Error", f"Batch analysis failed: {str(e)}")
            
            finally:
                self.is_analyzing = False
                self.batch_analyze_button.configure(text="Start Batch Analysis")
        
        thread = threading.Thread(target=run_batch_analysis)
        thread.start()

    def cancel_analysis(self):
        self.is_analyzing = False
        self.status_var.set("Analysis cancelled")
        self.batch_analyze_button.configure(text="Start Batch Analysis")

    def generate_individual_report(self, filepath, static_results, dynamic_results,
                                 ml_results, threat_results):
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = os.path.basename(filepath)
        report_dir = os.path.join('reports', 'batch_analysis', timestamp)
        os.makedirs(report_dir, exist_ok=True)
        
        report_file = os.path.join(report_dir, f"{filename}_report.html")
        
        # Generate report HTML (similar to generate_html_report but for individual file)
        # ... implementation details ...

    def update_yara_rules(self):
        try:
            self.static_analyzer._load_yara_rules()
            messagebox.showinfo("Success", "YARA rules updated successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update YARA rules: {str(e)}")

    def update_ml_model(self):
        try:
            self.ml_classifier._train_model()
            messagebox.showinfo("Success", "ML model updated successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update ML model: {str(e)}")

    def clear_cache(self):
        try:
            # Clear threat intelligence cache
            if os.path.exists(self.threat_intel.cache_file):
                os.remove(self.threat_intel.cache_file)
            
            # Reset cache
            self.threat_intel._initialize_cache()
            
            messagebox.showinfo("Success", "Cache cleared successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to clear cache: {str(e)}")

    def show_about(self):
        about_text = """Malware Classification System v1.0

A comprehensive tool for detecting and analyzing potential malware using:
‚Ä¢ Static Analysis
‚Ä¢ Dynamic Analysis
‚Ä¢ Machine Learning
‚Ä¢ Threat Intelligence

Features:
‚Ä¢ Multiple file analysis
‚Ä¢ Dark/Light theme
‚Ä¢ Detailed reporting
‚Ä¢ YARA rule matching
‚Ä¢ ML-based detection
‚Ä¢ Real-time threat intelligence

Created for advanced malware detection and analysis.
"""
        messagebox.showinfo("About", about_text)

    def show_error(self, message):
        error_frame = ttk.Frame(self.root)
        error_frame.place(relx=0.5, rely=0.1, anchor='n')
        
        error_label = ttk.Label(
            error_frame,
            text=f"‚ùå {message}",
            style='Info.TLabel',
            font=('Segoe UI', 12),
            foreground=self.current_colors['error']
        )
        error_label.pack(pady=10)
        
        self.root.after(3000, error_frame.destroy)

    def show_success(self, message):
        success_frame = ttk.Frame(self.root)
        success_frame.place(relx=0.5, rely=0.1, anchor='n')
        
        success_label = ttk.Label(
            success_frame,
            text=f"‚úÖ {message}",
            style='Info.TLabel',
            font=('Segoe UI', 12),
            foreground=self.current_colors['success']
        )
        success_label.pack(pady=10)
        
        self.root.after(3000, success_frame.destroy)

    def update_file_type_icons(self):
        """Update the file type icons based on the selected file."""
        for widget in self.file_type_frame.winfo_children():
            widget.destroy()
            
        file_path = self.file_path.get()
        if not file_path:
            return
            
        try:
            file_type = magic.from_file(file_path, mime=True)
            icon_text = {
                'application/x-executable': '‚öôÔ∏è',
                'application/x-dosexec': 'üéÆ',
                'application/x-msdos-program': 'üéÆ',
                'application/pdf': 'üìÑ',
                'text/plain': 'üìù',
                'application/zip': 'üì¶',
                'application/x-zip-compressed': 'üì¶',
                'application/msword': 'üìÉ',
                'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'üìÉ',
                'application/vnd.microsoft.portable-executable': '‚öôÔ∏è',
                'application/x-sharedlib': 'üìö',
                'application/x-object': '‚ö°',
                'application/java-archive': '‚òï',
                'application/x-java-archive': '‚òï',
                'text/x-python': 'üêç',
                'text/x-script.python': 'üêç',
                'application/x-python-code': 'üêç'
            }.get(file_type, 'üìÑ')
            
            # Create icon label
            ttk.Label(
                self.file_type_frame,
                text=f"{icon_text}",
                style='Info.TLabel',
                font=('Segoe UI', 16)
            ).pack(side=tk.LEFT, padx=5)
            
            # Create type label
            ttk.Label(
                self.file_type_frame,
                text=file_type,
                style='Info.TLabel',
                font=('Segoe UI', 10)
            ).pack(side=tk.LEFT, padx=5)
            
        except Exception as e:
            # If there's an error reading the file type, show a generic icon
            ttk.Label(
                self.file_type_frame,
                text="üìÑ Unknown file type",
                style='Info.TLabel',
                font=('Segoe UI', 10)
            ).pack(side=tk.LEFT, padx=5)

    def init_database(self):
        """Initialize SQLite database for analysis history."""
        try:
            # Create database directory if it doesn't exist
            db_dir = 'database'
            if not os.path.exists(db_dir):
                os.makedirs(db_dir)
            
            self.db_path = os.path.join(db_dir, 'analysis_history.db')
            # Don't keep a persistent connection - we'll create them as needed
            conn = self._get_db_connection()
            cursor = conn.cursor()
            
            # Create tables with better error handling
            try:
                # Drop existing analysis_trends table to recreate with correct schema
                cursor.execute('DROP TABLE IF EXISTS analysis_trends')
                
                # Analysis History table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS analysis_history (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_path TEXT NOT NULL,
                        file_hash TEXT NOT NULL,
                        file_type TEXT,
                        analysis_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        static_result TEXT,
                        dynamic_result TEXT,
                        ml_result TEXT,
                        threat_result TEXT,
                        risk_score FLOAT
                    )
                ''')
                
                # File Statistics table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS file_statistics (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        file_type TEXT UNIQUE,
                        detection_rate FLOAT DEFAULT 0,
                        analysis_count INTEGER DEFAULT 0,
                        last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # Analysis Trends table with proper schema
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS analysis_trends (
                        analysis_date TEXT PRIMARY KEY,
                        total_files INTEGER DEFAULT 0,
                        malicious_files INTEGER DEFAULT 0,
                        avg_risk_score FLOAT DEFAULT 0
                    )
                ''')
                
                conn.commit()
                self.show_success("Database initialized successfully")
                
            except sqlite3.Error as e:
                self.show_error(f"Database table creation error: {str(e)}")
                
            finally:
                cursor.close()
                conn.close()
                
        except Exception as e:
            self.show_error(f"Database initialization error: {str(e)}")

    def _get_db_connection(self):
        """Get a new database connection."""
        return sqlite3.connect(self.db_path)

    def store_analysis_results(self, filepath, static_results, dynamic_results,
                             ml_results, threat_results):
        """Store analysis results in the database with better error handling."""
        conn = None
        try:
            # Calculate file hash
            with open(filepath, 'rb') as f:
                file_hash = hashlib.sha256(f.read()).hexdigest()
            
            # Get file type
            try:
                file_type = magic.from_file(filepath, mime=True)
            except:
                file_type = 'unknown'
            
            # Extract risk score
            risk_score = float(ml_results.get('risk_score', 0))
            
            # Get a new connection for this thread
            conn = self._get_db_connection()
            cursor = conn.cursor()
            
            # Store in analysis history
            cursor.execute('''
                INSERT INTO analysis_history (
                    file_path, file_hash, file_type, analysis_time,
                    static_result, dynamic_result, ml_result, 
                    threat_result, risk_score
                ) VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, ?, ?, ?, ?)
            ''', (
                filepath, file_hash, file_type,
                json.dumps(static_results),
                json.dumps(dynamic_results),
                json.dumps(ml_results),
                json.dumps(threat_results),
                risk_score
            ))
            
            # Update file statistics
            cursor.execute('''
                INSERT INTO file_statistics (
                    file_type, detection_rate, analysis_count, last_updated
                ) VALUES (?, ?, 1, CURRENT_TIMESTAMP)
                ON CONFLICT(file_type) DO UPDATE SET
                    detection_rate = (
                        (detection_rate * analysis_count + ?) / (analysis_count + 1)
                    ),
                    analysis_count = analysis_count + 1,
                    last_updated = CURRENT_TIMESTAMP
            ''', (file_type, risk_score, risk_score))
            
            # Update trends
            self.update_analysis_trends(cursor)
            
            conn.commit()
            
        except Exception as e:
            if conn:
                conn.rollback()
            self.show_error(f"Failed to store analysis results: {str(e)}")
            
        finally:
            if conn:
                conn.close()

    def update_analysis_trends(self, cursor):
        """Update analysis trends data."""
        try:
            # Get today's date as string in YYYY-MM-DD format
            today = datetime.now().strftime('%Y-%m-%d')
            
            # Calculate daily statistics
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN risk_score > 50 THEN 1 ELSE 0 END) as malicious,
                    AVG(risk_score) as avg_score
                FROM analysis_history
                WHERE date(analysis_time) = date('now')
            ''')
            
            total, malicious, avg_score = cursor.fetchone()
            
            # Convert None values to 0
            total = total or 0
            malicious = malicious or 0
            avg_score = avg_score or 0
            
            # Update trends with proper UPSERT using REPLACE
            cursor.execute('''
                INSERT OR REPLACE INTO analysis_trends (
                    analysis_date, total_files, malicious_files, avg_risk_score
                ) VALUES (?, ?, ?, ?)
            ''', (today, total, malicious, avg_score))
            
        except Exception as e:
            self.show_error(f"Failed to update trends: {str(e)}")

    def show_statistics(self):
        """Show enhanced statistics dashboard."""
        stats_window = tk.Toplevel(self.root)
        stats_window.title("Statistics Dashboard")
        stats_window.geometry("1000x800")
        
        # Create notebook for different statistics
        notebook = ttk.Notebook(stats_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Summary statistics
        summary_frame = ttk.Frame(notebook)
        notebook.add(summary_frame, text="Summary")
        self.create_summary_stats(summary_frame)
        
        # Detection trends
        trends_frame = ttk.Frame(notebook)
        notebook.add(trends_frame, text="Detection Trends")
        self.create_trends_graph(trends_frame)
        
        # File type distribution
        types_frame = ttk.Frame(notebook)
        notebook.add(types_frame, text="File Types")
        self.create_file_type_chart(types_frame)
        
        # Add refresh button
        refresh_btn = ttk.Button(
            stats_window,
            text="Refresh Statistics",
            command=lambda: self.refresh_statistics(notebook),
            style='Accent.TButton'
        )
        refresh_btn.pack(pady=10)

    def refresh_statistics(self, notebook):
        """Refresh all statistics displays."""
        current_tab = notebook.select()
        
        # Clear and recreate all tabs
        for frame in notebook.winfo_children():
            frame.destroy()
        
        # Recreate tabs
        summary_frame = ttk.Frame(notebook)
        notebook.add(summary_frame, text="Summary")
        self.create_summary_stats(summary_frame)
        
        trends_frame = ttk.Frame(notebook)
        notebook.add(trends_frame, text="Detection Trends")
        self.create_trends_graph(trends_frame)
        
        types_frame = ttk.Frame(notebook)
        notebook.add(types_frame, text="File Types")
        self.create_file_type_chart(types_frame)
        
        # Restore previous tab selection
        notebook.select(current_tab)

    def create_summary_stats(self, parent):
        """Create enhanced summary statistics display."""
        try:
            # Create scrollable frame
            canvas = tk.Canvas(parent)
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            # Get database connection
            conn = self._get_db_connection()
            cursor = conn.cursor()
            
            # Fetch overall statistics
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN risk_score > 50 THEN 1 ELSE 0 END) as malicious,
                    AVG(risk_score) as avg_score,
                    MAX(analysis_time) as last_analysis
                FROM analysis_history
            ''')
            
            total, malicious, avg_score, last_analysis = cursor.fetchone()
            
            # Create statistics sections
            sections = [
                ("Overall Statistics", [
                    ("Total Files Analyzed", total or 0),
                    ("Malicious Files Detected", malicious or 0),
                    ("Average Risk Score", f"{avg_score:.1f}%" if avg_score else "0%"),
                    ("Last Analysis", last_analysis or "Never")
                ]),
                ("Today's Statistics", self.get_today_stats(cursor)),
                ("File Type Distribution", self.get_file_type_stats(cursor))
            ]
            
            cursor.close()
            conn.close()
            
            # Display sections
            for i, (section_title, stats) in enumerate(sections):
                ttk.Label(
                    scrollable_frame,
                    text=section_title,
                    font=('Segoe UI', 14, 'bold')
                ).grid(row=i*4, column=0, columnspan=2, pady=(20,10), sticky=tk.W)
                
                for j, (label, value) in enumerate(stats):
                    ttk.Label(
                        scrollable_frame,
                        text=label,
                        font=('Segoe UI', 11)
                    ).grid(row=i*4+j+1, column=0, padx=20, pady=5, sticky=tk.W)
                    
                    ttk.Label(
                        scrollable_frame,
                        text=str(value),
                        font=('Segoe UI', 11)
                    ).grid(row=i*4+j+1, column=1, padx=20, pady=5, sticky=tk.W)
            
            # Pack scrollable components
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
        except Exception as e:
            self.show_error(f"Failed to create summary statistics: {str(e)}")

    def get_today_stats(self, cursor):
        """Get today's analysis statistics."""
        try:
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN risk_score > 50 THEN 1 ELSE 0 END) as malicious,
                    AVG(risk_score) as avg_score
                FROM analysis_history
                WHERE date(analysis_time) = date('now')
            ''')
            
            total, malicious, avg_score = cursor.fetchone()
            
            return [
                ("Files Analyzed Today", total or 0),
                ("Malicious Files Today", malicious or 0),
                ("Today's Average Risk Score", f"{avg_score:.1f}%" if avg_score else "0%")
            ]
            
        except Exception:
            return [
                ("Files Analyzed Today", 0),
                ("Malicious Files Today", 0),
                ("Today's Average Risk Score", "0%")
            ]

    def get_file_type_stats(self, cursor):
        """Get file type statistics."""
        try:
            cursor.execute('''
                SELECT 
                    file_type,
                    COUNT(*) as count,
                    AVG(risk_score) as avg_score
                FROM analysis_history
                GROUP BY file_type
                ORDER BY count DESC
                LIMIT 5
            ''')
            
            stats = []
            for file_type, count, avg_score in cursor.fetchall():
                stats.append((
                    f"{file_type or 'Unknown'} Files",
                    f"{count} (Avg Risk: {avg_score:.1f}%)"
                ))
            
            return stats or [("No file type data", "N/A")]
            
        except Exception:
            return [("No file type data", "N/A")]

    def toggle_monitoring(self):
        """Toggle real-time system monitoring."""
        if not self.monitoring:
            self.monitoring = True
            self.monitor_thread = threading.Thread(target=self.monitor_system)
            self.monitor_thread.daemon = True
            self.monitor_thread.start()
            self.show_success("Real-time monitoring started")
        else:
            self.monitoring = False
            self.show_success("Real-time monitoring stopped")

    def monitor_system(self):
        """Monitor system for suspicious activities."""
        while self.monitoring:
            try:
                # Monitor processes
                for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                    if proc.info['cpu_percent'] > 80 or proc.info['memory_percent'] > 80:
                        self.log_suspicious_activity(proc.info)
                
                # Monitor network connections
                connections = psutil.net_connections()
                for conn in connections:
                    if conn.status == 'ESTABLISHED' and conn.raddr:
                        self.check_suspicious_connection(conn)
                
                time.sleep(5)  # Check every 5 seconds
            except Exception as e:
                self.show_error(f"Monitoring error: {str(e)}")
                break

    def log_suspicious_activity(self, proc_info):
        """Log suspicious process activity."""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] High resource usage detected:\n"
        log_entry += f"Process: {proc_info['name']} (PID: {proc_info['pid']})\n"
        log_entry += f"CPU: {proc_info['cpu_percent']}% | Memory: {proc_info['memory_percent']}%\n\n"
        
        if 'Dynamic Analysis' in self.text_widgets:
            self.text_widgets['Dynamic Analysis'].insert(tk.END, log_entry)

    def check_suspicious_connection(self, connection):
        """Check for suspicious network connections."""
        if hasattr(connection, 'raddr') and connection.raddr:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            log_entry = f"[{timestamp}] Network connection detected:\n"
            log_entry += f"Local: {connection.laddr}\n"
            log_entry += f"Remote: {connection.raddr}\n"
            log_entry += f"Status: {connection.status}\n\n"
            
            if 'Dynamic Analysis' in self.text_widgets:
                self.text_widgets['Dynamic Analysis'].insert(tk.END, log_entry)

    def toggle_sandbox(self):
        """Toggle sandbox environment for safe analysis."""
        if not self.sandbox_active:
            try:
                # Initialize sandbox environment
                self.sandbox_active = True
                self.show_success("Sandbox environment activated")
            except Exception as e:
                self.show_error(f"Failed to activate sandbox: {str(e)}")
        else:
            self.sandbox_active = False
            self.show_success("Sandbox environment deactivated")

    def show_history(self):
        """Show analysis history window."""
        history_window = tk.Toplevel(self.root)
        history_window.title("Analysis History")
        history_window.geometry("800x600")
        history_window.configure(bg=self.current_colors['background'])
        
        # Create main frame
        main_frame = ttk.Frame(history_window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create tree view
        columns = ('Date', 'File', 'Type', 'Risk Score', 'Status')
        tree = ttk.Treeview(main_frame, columns=columns, show='headings')
        
        # Configure columns
        tree.heading('Date', text='Date')
        tree.heading('File', text='File Name')
        tree.heading('Type', text='File Type')
        tree.heading('Risk Score', text='Risk Score')
        tree.heading('Status', text='Status')
        
        tree.column('Date', width=150)
        tree.column('File', width=200)
        tree.column('Type', width=150)
        tree.column('Risk Score', width=100)
        tree.column('Status', width=100)
        
        # Add scrollbars
        y_scrollbar = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=tree.yview)
        x_scrollbar = ttk.Scrollbar(main_frame, orient=tk.HORIZONTAL, command=tree.xview)
        tree.configure(yscrollcommand=y_scrollbar.set, xscrollcommand=x_scrollbar.set)
        
        # Pack the tree and scrollbars
        tree.grid(row=0, column=0, sticky='nsew')
        y_scrollbar.grid(row=0, column=1, sticky='ns')
        x_scrollbar.grid(row=1, column=0, sticky='ew')
        
        # Configure grid weights
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=1)
        
        def load_history():
            try:
                # Clear existing items
                for item in tree.get_children():
                    tree.delete(item)
                
                # Get database connection
                conn = self._get_db_connection()
                cursor = conn.cursor()
                
                # Fetch history data
                cursor.execute('''
                    SELECT 
                        datetime(analysis_time) as time_stamp,
                        file_path,
                        file_type,
                        risk_score,
                        static_result,
                        dynamic_result,
                        ml_result,
                        threat_result
                    FROM analysis_history
                    ORDER BY analysis_time DESC
                ''')
                
                for row in cursor.fetchall():
                    try:
                        time_stamp, file_path, file_type, risk_score, static_result, dynamic_result, ml_result, threat_result = row
                        
                        # Convert risk score to float, default to 0 if None
                        risk_score = float(risk_score) if risk_score is not None else 0
                        
                        # Determine status based on risk score
                        if risk_score > 70:
                            status = 'Malicious'
                            tag = 'malicious'
                        elif risk_score > 40:
                            status = 'Suspicious'
                            tag = 'suspicious'
                        else:
                            status = 'Clean'
                            tag = 'clean'
                        
                        # Insert into tree
                        tree.insert('', 'end', values=(
                            time_stamp,  # SQLite datetime string
                            os.path.basename(file_path),
                            file_type or 'Unknown',
                            f"{risk_score:.1f}%",
                            status
                        ), tags=(tag,))
                        
                    except Exception as e:
                        print(f"Error processing row: {e}")
                        continue
                
                # Configure tags for color coding
                tree.tag_configure('malicious', foreground='red')
                tree.tag_configure('suspicious', foreground='orange')
                tree.tag_configure('clean', foreground='green')
                
                cursor.close()
                conn.close()
                
            except Exception as e:
                self.show_error(f"Failed to load history: {str(e)}")
        
        # Add refresh button
        refresh_btn = ttk.Button(main_frame, text="Refresh", command=load_history, style='Accent.TButton')
        refresh_btn.grid(row=2, column=0, pady=10)
        
        # Initial load
        load_history()
        
        # Make the window resizable
        history_window.resizable(True, True)

    def create_trends_graph(self, parent):
        """Create detection trends graph."""
        try:
            # Get database connection
            conn = self._get_db_connection()
            cursor = conn.cursor()
            
            # Fetch trend data
            cursor.execute('''
                SELECT analysis_date, avg_risk_score
                FROM analysis_trends
                ORDER BY analysis_date
            ''')
            
            dates = []
            scores = []
            for row in cursor.fetchall():
                dates.append(row[0])
                scores.append(row[1])
            
            cursor.close()
            conn.close()
            
            if not dates:  # If no data
                ttk.Label(
                    parent,
                    text="No trend data available",
                    font=('Segoe UI', 12)
                ).pack(pady=20)
                return
            
            # Create matplotlib figure
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.plot(dates, scores, marker='o')
            ax.set_title('Detection Score Trends')
            ax.set_xlabel('Date')
            ax.set_ylabel('Average Risk Score')
            plt.xticks(rotation=45)
            
            # Embed in tkinter
            canvas = FigureCanvasTkAgg(fig, parent)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except Exception as e:
            self.show_error(f"Failed to create trends graph: {str(e)}")

    def create_file_type_chart(self, parent):
        """Create file type distribution chart."""
        try:
            # Get database connection
            conn = self._get_db_connection()
            cursor = conn.cursor()
            
            # Fetch file type data
            cursor.execute('''
                SELECT file_type, COUNT(*) as count
                FROM analysis_history
                GROUP BY file_type
            ''')
            
            types = []
            counts = []
            for row in cursor.fetchall():
                types.append(row[0] or 'Unknown')
                counts.append(row[1])
            
            cursor.close()
            conn.close()
            
            if not types:  # If no data
                ttk.Label(
                    parent,
                    text="No file type data available",
                    font=('Segoe UI', 12)
                ).pack(pady=20)
                return
            
            # Create pie chart
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.pie(counts, labels=types, autopct='%1.1f%%')
            ax.set_title('File Type Distribution')
            
            # Embed in tkinter
            canvas = FigureCanvasTkAgg(fig, parent)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        except Exception as e:
            self.show_error(f"Failed to create file type chart: {str(e)}")

    def exit_application(self):
        """Safely exit the application."""
        try:
            # Close any open database connections
            if hasattr(self, 'db_path'):
                try:
                    conn = self._get_db_connection()
                    conn.close()
                except:
                    pass
            
            # Destroy all toplevel windows
            for widget in self.root.winfo_children():
                if isinstance(widget, tk.Toplevel):
                    widget.destroy()
            
            # Destroy main window
            self.root.quit()
            self.root.destroy()
            
        except Exception as e:
            print(f"Error during exit: {e}")
            sys.exit(1)

def main():
    """Main application entry point."""
    try:
        root = tk.Tk()
        app = MalwareClassifierGUI(root)
        
        # Handle window close button
        root.protocol("WM_DELETE_WINDOW", app.exit_application)
        
        # Handle Ctrl+C in terminal
        def signal_handler(sig, frame):
            print("\nExiting gracefully...")
            app.exit_application()
        
        if hasattr(signal, 'SIGINT'):
            signal.signal(signal.SIGINT, signal_handler)
        
        root.mainloop()
        
    except KeyboardInterrupt:
        print("\nExiting gracefully...")
        try:
            root.quit()
            root.destroy()
        except:
            pass
        sys.exit(0)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 